<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FeatherMyth — Hyrule‑ish (3 rooms)</title>
<style>
  :root{
    --bg:#0e0e10; --hud:#e5e5e5; --accent:#7cf; --accent2:#f7a; --shadow: rgba(0,0,0,.6);
    --grass:#1e5d39; --grass2:#2c7d4f; --stone:#3b3f4b; --stone2:#53586a; --carpet:#6e0a16; --carpet2:#8f0f1e;
    --door:#000; --player:#ffefc2; --sword:#f7e39f; --boomer:#bde3ff; --rupee:#7fffd4;
    --bat:#9b59b6; --centi:#f4d35e;
  }
  html,body{height:100%;margin:0;background:#0a0b12;color:var(--hud);font-family: ui-monospace, Menlo, Consolas, monospace}
  .wrap{height:100%;display:grid;place-items:center;padding:1rem}
  .frame{position:relative;width:min(96vw, 1120px);aspect-ratio:4/3;border-radius:18px;overflow:hidden;background:#06070b;box-shadow:0 24px 64px rgba(0,0,0,.7), inset 0 0 0 2px rgba(255,255,255,.06)}
  canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering: pixelated;display:block}
  .hud{position:absolute;inset:auto 12px 10px 12px;display:flex;justify-content:space-between;pointer-events:none;font-size:clamp(12px,1.5vw,15px);text-shadow:0 2px 0 #000,0 0 6px var(--shadow)}
  .legend{position:absolute;left:12px;top:10px;font-size:clamp(11px,1.4vw,14px);color:#cfe1ff;opacity:.9;text-shadow:0 2px 0 #000,0 0 6px var(--shadow);user-select:none}
  .badge{display:inline-block;padding:.08rem .4rem;border-radius:6px;background:rgba(255,255,255,.08);box-shadow: inset 0 0 0 1px rgba(255,255,255,.15);margin-left:.35rem}
</style>
</head>
<body>
<div class="wrap">
  <div class="frame" id="frame">
    <canvas id="game"></canvas>
    <canvas id="fx"></canvas>
    <div class="legend">
      <strong>FeatherMyth</strong> <span class="badge">3 rooms (Start → Right → Up)</span><br>
      Move: <b>WASD / Arrows</b> · Sword: <b>Z</b> · Boomerang: <b>X</b>
    </div>
    <div class="hud"><div id="hearts"></div><div id="stats"></div></div>
  </div>
</div>
<script>
(()=>{
  // ===== Resolution & canvas =====
  const LOG_W = 256, LOG_H = 192; // compact 4:3-ish NES vibe
  const frame = document.getElementById('frame');
  const game = document.getElementById('game');
  const fx = document.getElementById('fx');
  const heartsEl = document.getElementById('hearts');
  const statsEl = document.getElementById('stats');
  function resize(){ game.width=LOG_W; game.height=LOG_H; fx.width=LOG_W; fx.height=LOG_H; }
  window.addEventListener('resize', resize); resize();
  const ctx = game.getContext('2d');
  const ftx = fx.getContext('2d');

  // ===== Color palette (stored as constants instead of CSS vars) =====
  const colors = {
    grass: '#1e5d39', grass2: '#2c7d4f', 
    stone: '#3b3f4b', stone2: '#53586a', 
    carpet: '#6e0a16', carpet2: '#8f0f1e',
    door: '#000', player: '#ffefc2', 
    sword: '#f7e39f', boomer: '#bde3ff', 
    rupee: '#7fffd4', bat: '#9b59b6', 
    centi: '#f4d35e', accent: '#7cf'
  };

  // ===== Utilities =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rng=(a,b)=>a+Math.random()*(b-a);
  const AABB=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;

  // ===== Input =====
  const keys=new Map(), once=new Map();
  const mapKey = (c) => (
    (c==='ArrowUp'||c==='KeyW') ? 'up' :
    (c==='ArrowDown'||c==='KeyS') ? 'down' :
    (c==='ArrowLeft'||c==='KeyA') ? 'left' :
    (c==='ArrowRight'||c==='KeyD') ? 'right' :
    (c==='KeyZ') ? 'sword' :
    (c==='KeyX') ? 'boom' :
    null
  );
  addEventListener('keydown',e=>{const k=mapKey(e.code); if(!k) return; if(!keys.get(k)) once.set(k,true); keys.set(k,true); e.preventDefault();});
  addEventListener('keyup',e=>{const k=mapKey(e.code); if(!k) return; keys.set(k,false); e.preventDefault();});

  // ===== Game state =====
  const player={x:112,y:120,w:10,h:12,vx:0,vy:0,spd:1.4,face:'down',hp:30,inv:0,hasSword:false,hasBoom:false,alive:true};
  const inventory={rupees:0};
  let victoryLight = 0; // For throne room victory effect

  // Rooms graph: 1 (start, rain) -> right -> 2 (grey, no rain) -> up -> 3 (throne, rain + lightning)
  const ROOM={ START:1, GREY:2, THRONE:3 };
  let room = ROOM.START;

  // Enemy System
  class Enemy {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.alive = true;
      this.frozen = 0;
      this.flash = 0;
      this.id = Math.random(); // Unique ID for tracking hits
    }

    dispatch(event, data = {}) {
      switch(event) {
        case 'update': return this.update(data.dt);
        case 'draw': return this.draw(data.ctx);
        case 'damage': return this.takeDamage(data.amount, data.source);
        case 'freeze': return this.freeze(data.duration);
        case 'collide': return this.checkCollision(data.box);
        case 'pointHit': return this.checkPointHit(data.x, data.y);
        case 'death': return this.onDeath(data.room);
      }
    }

    update(dt) {
      if (!this.alive) return;
      if (this.frozen > 0) { this.frozen--; return; }
      if (this.flash > 0) this.flash--;
    }

    draw(ctx) {
      if (!this.alive) return;
    }

    takeDamage(amount, source) {
      if (!this.alive) return false;
      this.hp -= amount;
      this.flash = 10;
      if (this.hp <= 0) {
        this.alive = false;
        return true; // died
      }
      return false; // still alive
    }

    freeze(duration) {
      this.frozen = duration;
      this.flash = 10;
    }

    checkCollision(box) {
      return AABB(box, this);
    }

    checkPointHit(x, y) {
      return x >= this.x && x <= this.x + this.w && y >= this.y && y <= this.y + this.h;
    }

    onDeath(room) {
      dropRupee(room, this.x + this.w/2, this.y + this.h/2);
    }

    getHitbox() {
      return {x: this.x, y: this.y, w: this.w, h: this.h};
    }

    getCenter() {
      return {x: this.x + this.w/2, y: this.y + this.h/2};
    }
  }

  class Bat extends Enemy {
    constructor(x, y) {
      super(x, y, 'bat');
      this.w = 10;
      this.h = 8;
      this.hp = 10;
      this.speed = 0.9 + Math.random() * 0.3;
      this.theta = Math.random() * Math.PI * 2;
      this.omega = (Math.random() < 0.5 ? -1 : 1) * (0.02 + rng(0, 0.02));
      this.vx = 0;
      this.vy = 0;
    }

    update(dt) {
      super.update(dt);
      if (!this.alive || this.frozen > 0) return;

      // Spiral/circular drift
      this.theta += this.omega;
      this.vx = Math.cos(this.theta) * this.speed;
      this.vy = Math.sin(this.theta) * this.speed;
      
      // Test new position before moving
      const newX = this.x + this.vx;
      const newY = this.y + this.vy;
      
      // Check walls and bounce
      let bounced = false;
      if (newX < 8 || newX + this.w > LOG_W - 8) {
        this.theta = Math.PI - this.theta;
        this.omega *= -1;
        bounced = true;
      }
      if (newY < 16 || newY + this.h > LOG_H - 8) {
        this.theta = -this.theta;
        this.omega *= -1;
        bounced = true;
      }
      
      // If bounced, recalculate velocity
      if (bounced) {
        this.vx = Math.cos(this.theta) * this.speed;
        this.vy = Math.sin(this.theta) * this.speed;
      }
      
      // Apply movement with clamping as safety
      this.x = clamp(this.x + this.vx, 8, LOG_W - 8 - this.w);
      this.y = clamp(this.y + this.vy, 16, LOG_H - 8 - this.h);
    }

    draw(ctx) {
      if (!this.alive) return;
      ctx.fillStyle = (this.flash > 0 && Math.floor(this.flash/2) % 2 === 0) ? '#fff' : colors.bat;
      ctx.fillRect(this.x, this.y, this.w, this.h);
      if (this.flash <= 0) {
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 2, this.y + 2, 2, 2);
      }
    }
  }

  class Centipede extends Enemy {
    constructor() {
      const w = 10, h = 10;
      super(LOG_W/2 - w/2, 40, 'centi');
      this.w = w;
      this.h = h;
      this.segs = 4;
      this.baseSpeed = 1.8;
      this.speed = this.baseSpeed;
      this.spacing = 8;
      this.dir = 'right';
      this.dist = 0;
      this.must = Math.min(LOG_W, LOG_H) / 5;
      this.head = {x: this.x, y: this.y, w: this.w, h: this.h};
      this.path = [];
      this.bodies = new Array(this.segs - 1).fill(0).map(_ => ({x: this.head.x, y: this.head.y, w: this.w, h: this.h}));
      this.hp = this.segs; // HP based on segments
    }

    update(dt) {
      super.update(dt);
      if (!this.alive || this.frozen > 0) return;

      const head = this.head;
      const sp = this.speed;
      const prev = {x: head.x, y: head.y};
      
      // Move head
      if (this.dir === 'right') head.x += sp;
      else if (this.dir === 'left') head.x -= sp;
      else if (this.dir === 'up') head.y -= sp;
      else head.y += sp;
      
      this.dist += sp;
      
      // Wall check
      let hitWall = false;
      if (head.x < 8) { head.x = 8; hitWall = true; }
      if (head.x + head.w > LOG_W - 8) { head.x = LOG_W - 8 - head.w; hitWall = true; }
      if (head.y < 16) { head.y = 16; hitWall = true; }
      if (head.y + head.h > LOG_H - 8) { head.y = LOG_H - 8 - head.h; hitWall = true; }

      // Push to path
      this.path.push({x: prev.x, y: prev.y});
      if (this.path.length > 800) this.path.shift();

      // Change direction if needed
      if (hitWall || this.dist >= this.must) {
        this.dir = this.chooseNewDirection();
        this.dist = 0;
      }

      // Update body segments
      this.updateBodySegments();
      
      // Update main position for collision detection
      this.x = head.x;
      this.y = head.y;
    }

    chooseNewDirection() {
      const dx = player.x - this.head.x;
      const dy = player.y - this.head.y;
      
      const options = ['straight', 'left', 'right'];
      const candidates = options.map(turn => {
        const newDir = this.tryTurn(this.dir, turn);
        const test = {x: this.head.x, y: this.head.y, w: this.w, h: this.h};
        
        if (newDir === 'right') test.x += 8;
        else if (newDir === 'left') test.x -= 8;
        else if (newDir === 'up') test.y -= 8;
        else test.y += 8;
        
        const valid = test.x >= 8 && test.x + test.w <= LOG_W - 8 && 
                     test.y >= 16 && test.y + test.h <= LOG_H - 8;
        
        const distToPlayer = Math.abs(test.x - player.x) + Math.abs(test.y - player.y);
        
        return {turn, dir: newDir, valid, distToPlayer};
      });
      
      candidates.sort((a, b) => a.distToPlayer - b.distToPlayer);
      const validMoves = candidates.filter(c => c.valid);
      
      const picked = validMoves[0] || candidates.find(c => c.turn !== 'straight' && c.valid) || candidates[0];
      return picked.dir;
    }

    tryTurn(dir, turn) {
      if (turn === 'straight') return dir;
      const dirs = ['up', 'right', 'down', 'left'];
      let idx = dirs.indexOf(dir);
      idx = (idx + (turn === 'right' ? 1 : 3)) % 4;
      return dirs[idx];
    }

    updateBodySegments() {
      const need = (this.segs - 1) * this.spacing;
      while (this.path.length < need) {
        this.path.unshift({x: this.head.x, y: this.head.y});
      }
      for (let i = 0; i < this.bodies.length; i++) {
        const idx = this.path.length - 1 - (i + 1) * this.spacing;
        const p = this.path[Math.max(0, idx)];
        this.bodies[i].x = p.x;
        this.bodies[i].y = p.y;
      }
    }

    draw(ctx) {
      if (!this.alive) return;
      ctx.fillStyle = (this.flash > 0 && Math.floor(this.flash/2) % 2 === 0) ? '#fff' : colors.centi;
      ctx.fillRect(this.head.x, this.head.y, this.w, this.h);
      for (const s of this.bodies) {
        ctx.fillRect(s.x, s.y, this.w, this.h);
      }
    }

    checkCollision(box) {
      if (AABB(box, this.head)) return true;
      for (const s of this.bodies) {
        if (AABB(box, s)) return true;
      }
      return false;
    }

    checkPointHit(x, y) {
      const pt = {x: x - 1, y: y - 1, w: 2, h: 2};
      return this.checkCollision(pt);
    }

    takeDamage(amount, source) {
      if (!this.alive) return false;
      
      // For centipede, damage removes segments
      if (this.bodies.length > 0) {
        this.bodies.pop();
        this.segs--;
        // Speed up by 15% for each lost segment
        this.speed = this.baseSpeed * (1 + 0.15 * (4 - this.segs));
        this.flash = 10;
        return false; // still alive
      } else {
        // Head dies
        this.alive = false;
        return true; // died
      }
    }

    onDeath(room) {
      super.onDeath(room);
      
      // Trigger victory effect in throne room
      if (room.id === ROOM.THRONE) {
        victoryLight = 1.0;
        room.rain = false;
        room.lightning = false;
      }
    }

    getHitbox() {
      // Return array of hitboxes for centipede
      return [this.head, ...this.bodies];
    }

    getCenter() {
      return {x: this.head.x + this.w/2, y: this.head.y + this.h/2};
    }
  }

  // Enemy Factory
  const EnemyFactory = {
    createBat: (x, y) => new Bat(x, y),
    createCentipede: () => new Centipede()
  };

  // Room definitions
  function makeRoom(id){
    const base={id, enemies:[], pickups:[], rupees:[], rain:false, lightning:false, carpet:false, doors:[]};
    if(id===ROOM.START){
      base.rain=true;
      base.bg='grass';
      // sword pickup
      base.pickups.push({kind:'sword', x:120, y:136, w:10, h:10, taken:false});
      // doors: right -> GREY
      base.doors.push({dir:'right', to:ROOM.GREY, x:LOG_W-10, y:LOG_H/2-12, w:10, h:24});
    } else if(id===ROOM.GREY){
      base.bg='stone'; base.rain=false; // explicitly off
      // boomerang pickup
      base.pickups.push({kind:'boom', x:128, y:96, w:10,h:10, taken:false});
      // 3 bats using factory
      for(let i=0;i<3;i++) base.enemies.push(EnemyFactory.createBat(60+ i*50, 50 + i*20));
      base.doors.push({dir:'left', to:ROOM.START, x:0, y:LOG_H/2-12, w:10, h:24});
      // Fixed: door properly in the wall at y:14 (wall is 14-18)
      base.doors.push({dir:'up', to:ROOM.THRONE, x:LOG_W/2-12, y:14, w:24, h:10});
    } else if(id===ROOM.THRONE){
      base.bg='stone'; base.carpet=true; base.rain=true; base.lightning=true;
      // centipede boss using factory
      base.enemies.push(EnemyFactory.createCentipede());
      base.pickups.push({kind:'heart', x:LOG_W-32, y:LOG_H-28, w:10,h:10, taken:false});
      base.doors.push({dir:'down', to:ROOM.GREY, x:LOG_W/2-12, y:LOG_H-10, w:24, h:10});
    }
    return base;
  }

  let rooms={ [ROOM.START]: makeRoom(ROOM.START), [ROOM.GREY]: makeRoom(ROOM.GREY), [ROOM.THRONE]: makeRoom(ROOM.THRONE) };

  function resetRooms(){ rooms={ [ROOM.START]: makeRoom(ROOM.START), [ROOM.GREY]: makeRoom(ROOM.GREY), [ROOM.THRONE]: makeRoom(ROOM.THRONE) }; }

  // ===== Projectiles & attacks =====
  const melee={active:false, t:0, dur:8, box:{x:0,y:0,w:12,h:12}};
  let boomer=null; // returning projectile

  function startSlash(){ if(!player.hasSword||melee.active) return; melee.active=true; melee.t=melee.dur; }
  function throwBoom(){ if(!player.hasBoom||boomer) return; const d=dirVec(player.face); boomer={x:player.x+player.w/2, y:player.y+player.h/2, vx:d.x*2.2, vy:d.y*2.2, max:64, dist:0, returning:false, hitIds:new Map()}; }
  function dirVec(face){ return face==='up'?{x:0,y:-1}: face==='down'?{x:0,y:1}: face==='left'?{x:-1,y:0}:{x:1,y:0}; }

  // ===== Rain & lightning =====
  const drops=[]; function initRain(){ drops.length=0; for(let i=0;i<100;i++) drops.push({x:Math.random()*LOG_W,y:Math.random()*LOG_H,len:6+Math.random()*8,spd:1.8+Math.random()*1.5}); }
  initRain();
  function drawRain(){
    ftx.clearRect(0,0,LOG_W,LOG_H);
    
    // Victory light effect (golden halo)
    if (victoryLight > 0) {
      const gradient = ftx.createRadialGradient(LOG_W/2, LOG_H/2, 0, LOG_W/2, LOG_H/2, Math.max(LOG_W, LOG_H)/2);
      gradient.addColorStop(0, `rgba(255, 230, 100, ${victoryLight * 0.5})`);
      gradient.addColorStop(0.5, `rgba(255, 210, 50, ${victoryLight * 0.3})`);
      gradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
      ftx.fillStyle = gradient;
      ftx.fillRect(0, 0, LOG_W, LOG_H);
      
      // Slowly fade out
      //victoryLight = Math.max(0, victoryLight - 0.002);
    }
    
    if(!rooms[room].rain){ return; }
    ftx.globalAlpha=.65; ftx.strokeStyle='rgba(160,200,255,0.8)'; ftx.lineWidth=1; ftx.beginPath();
    for(const d of drops){
      ftx.moveTo(d.x,d.y); ftx.lineTo(d.x-2,d.y+d.len);
      d.x-=0.6*d.spd; d.y+=d.spd;
      if(d.y>LOG_H+8){ d.y=-8; d.x=Math.random()*LOG_W;}
      if(d.x<-8){ d.x=LOG_W+8; }
    }
    ftx.stroke(); ftx.globalAlpha=1;
    if(lightFlash>0){ ftx.fillStyle=`rgba(255,255,255,${lightFlash})`; ftx.fillRect(0,0,LOG_W,LOG_H); }
  }
  let lightTimer= rng(90,200), lightFlash=0;

  // ===== Drawing helpers =====
  function drawRoomBG(r){
    if(r.bg==='grass'){
      // dithered grass
      ctx.fillStyle=colors.grass; ctx.fillRect(0,0,LOG_W,LOG_H);
      ctx.fillStyle=colors.grass2; for(let y=16; y<LOG_H; y+=8){ for(let x=(y%16?4:0); x<LOG_W; x+=8){ ctx.fillRect(x,y,4,4); } }
    } else { // stone
      ctx.fillStyle=colors.stone; ctx.fillRect(0,0,LOG_W,LOG_H);
      ctx.fillStyle=colors.stone2; for(let y=16; y<LOG_H; y+=12){ for(let x=(y%24?6:0); x<LOG_W; x+=12){ ctx.fillRect(x,y,6,6); } }
    }
    // top HUD gutter line
    ctx.fillStyle='rgba(0,0,0,.4)'; ctx.fillRect(0,0,LOG_W,14);
    // carpet in throne
    if(r.carpet){
      const w=LOG_W-40, h=LOG_H-70, x=(LOG_W-w)/2, y=24;
      ctx.fillStyle=colors.carpet; ctx.fillRect(x,y,w,h);
      ctx.fillStyle=colors.carpet2; for(let i=0;i<4;i++) ctx.fillRect(x+4+i*3, y+4+i*3, w-8-i*6, 2);
      // throne
      ctx.fillStyle='#1d0e0e'; ctx.fillRect(LOG_W/2-10, y+8, 20, 14);
      ctx.fillStyle='#3b1b1b'; ctx.fillRect(LOG_W/2-8, y+10, 16, 10);
    }
    // walls - draw before doors so doors overlay properly
    ctx.fillStyle='#0b0c11'; 
    ctx.fillRect(0,14,LOG_W,4); // top wall
    ctx.fillRect(0,14,4,LOG_H-14); // left wall
    ctx.fillRect(LOG_W-4,14,4,LOG_H-14); // right wall
    ctx.fillRect(0,LOG_H-4,LOG_W,4); // bottom wall
    // doors (black rectangles) - draw after walls so they overlay
    for(const d of r.doors){ ctx.fillStyle=colors.door; ctx.fillRect(d.x,d.y,d.w,d.h); }
  }

  function drawPlayer(){
    const p=player; // body
    // flicker while invincible
    if(p.inv>0 && (Math.floor(perf/60)%2===0)) return;
    ctx.fillStyle='#2b2b2b'; ctx.fillRect(p.x-1,p.y-1,p.w+2,p.h+2);
    ctx.fillStyle=colors.player; ctx.fillRect(p.x,p.y,p.w,p.h);
    // face stripe
    ctx.fillStyle=colors.accent; ctx.fillRect(p.x+2,p.y+2,p.w-4,2);
  }

  function drawEnemies(r){
    for(const e of r.enemies){
      e.dispatch('draw', {ctx});
    }
  }

  function drawPickups(r){
    for(const it of r.pickups){ if(it.taken) continue; if(it.kind==='sword'){ ctx.fillStyle=colors.sword; ctx.fillRect(it.x,it.y,it.w,it.h); ctx.fillStyle='#6b5b2a'; ctx.fillRect(it.x+3,it.y+2,4,2); }
      else if(it.kind==='boom'){ ctx.fillStyle=colors.boomer; ctx.fillRect(it.x,it.y,it.w,it.h); ctx.fillStyle='#6aa2d8'; ctx.fillRect(it.x+1,it.y+4,it.w-2,2); }
      else if(it.kind==='heart'){ ctx.fillStyle='#ff4d4d'; ctx.fillRect(it.x,it.y,it.w,it.h); }
    }
  }

  function drawRupees(r){ ctx.fillStyle=colors.rupee; for(const g of r.rupees){ ctx.fillRect(g.x,g.y,g.w,g.h); ctx.fillStyle='#b7ffe6'; ctx.fillRect(g.x+2,g.y+2, g.w-4, g.h-4); ctx.fillStyle=colors.rupee; } }

  function drawMelee(){ if(!melee.active) return; const b=melee.box; ctx.fillStyle='rgba(255,240,160,.85)'; ctx.fillRect(b.x,b.y,b.w,b.h); }
  function drawBoom(){ if(!boomer) return; ctx.fillStyle=colors.boomer; ctx.fillRect(boomer.x-3, boomer.y-3, 6, 6); }

  function drawHUD(){
    // hearts (3 boxes)
    const hp=player.hp; const full=hp>=30?3:hp>=20?2:hp>=10?1:0; // boxes not partial per spec
    let html=''; for(let i=0;i<3;i++){ const on=i<full; html+=`<span style="display:inline-block;width:18px;height:12px;border:1px solid #000;background:${on?'#ff5252':'#111'};box-shadow: inset 0 0 0 1px rgba(255,255,255,.2);margin-right:6px"></span>`; }
    heartsEl.innerHTML=html;
    const hasS=player.hasSword?'Yes':'—', hasB=player.hasBoom?'Yes':'—';
    statsEl.innerHTML=`Rupees: <b>${inventory.rupees}</b> · Sword: <b>${hasS}</b> · Boomerang: <b>${hasB}</b>`;
  }

  // ===== Room transitions (scroll) =====
  // Player disappears during scroll; new room slides in; player reappears at the matching entrance
  let transState=null; // {from,to,dir,prog}
  function beginTransition(to, dir){ if(transState) return; transState={from:room,to,dir,prog:0}; }
  function renderTransition(dt){ if(!transState) return false; const sp=0.08; transState.prog+=sp*dt; const p=Math.min(1,transState.prog);
    const from=rooms[transState.from], to=rooms[transState.to];
    const dx = transState.dir==='right' ? -p*LOG_W : transState.dir==='left' ? p*LOG_W : 0;
    const dy = transState.dir==='up' ? p*LOG_H : transState.dir==='down' ? -p*LOG_H : 0;
    ctx.save(); ctx.translate(dx,dy); drawRoomBG(from); drawPickups(from); drawEnemies(from); drawRupees(from); ctx.restore();
    const tx = transState.dir==='right' ? LOG_W+dx : transState.dir==='left' ? -LOG_W+dx : 0;
    const ty = transState.dir==='up' ? -LOG_H+dy : transState.dir==='down' ? LOG_H+dy : 0;
    ctx.save(); ctx.translate(tx,ty); drawRoomBG(to); drawPickups(to); drawEnemies(to); drawRupees(to); ctx.restore();
    if(p>=1){ room=transState.to; finalizeSpawn(opposite(transState.dir)); transState=null; }
    return true;
  }
  function opposite(dir){ return dir==='left'?'right':dir==='right'?'left':dir==='up'?'down':'up'; }
  function finalizeSpawn(dir){
    // Fixed: spawn from the opposite entrance direction
    // When entering from left, player came from right, so spawn on left side
    if(dir==='left'){ player.x=20; player.y=LOG_H/2-6; player.face='right'; }
    if(dir==='right'){ player.x=LOG_W-30; player.y=LOG_H/2-6; player.face='left'; }
    if(dir==='down'){ player.x=LOG_W/2-6; player.y=LOG_H-30; player.face='up'; }
    if(dir==='up'){ player.x=LOG_W/2-6; player.y=32; player.face='down'; }
  }

  // ===== Game loop =====
  let perf=performance.now();
  function loop(now){
    const dt=clamp((now-perf)/(1000/60),0.5,2.0); perf=now;
    // Lightning scheduling
    if(rooms[room].lightning){ lightTimer--; if(lightTimer<=0){ lightFlash=0.85; lightTimer=rng(120,260);} if(lightFlash>0) lightFlash=Math.max(0, lightFlash-0.08*dt); } else { lightFlash=0; lightTimer=rng(90,200); }

    // Input & movement (disabled during transition)
    if(!transState){
      const up=!!keys.get('up'), dn=!!keys.get('down'), lf=!!keys.get('left'), rt=!!keys.get('right');
      player.vx = (rt?player.spd:0) + (lf?-player.spd:0);
      player.vy = (dn?player.spd:0) + (up?-player.spd:0);
      if(Math.abs(player.vx)+Math.abs(player.vy)>0){ if(rt) player.face='right'; else if(lf) player.face='left'; else if(up) player.face='up'; else if(dn) player.face='down'; }
      player.x = clamp(player.x + player.vx, 8, LOG_W-8-player.w);
      player.y = clamp(player.y + player.vy, 16, LOG_H-8-player.h);

      // Attacks
      if(once.get('sword')){ startSlash(); once.set('sword',false); }
      if(once.get('boom')){ throwBoom(); once.set('boom',false); }

      // Melee box placement
      if(melee.active){
        melee.t--; if(melee.t<=0){ melee.active=false; } else {
          const b=melee.box; const range=12; const d=dirVec(player.face);
          b.w = d.x!==0?12:8; b.h=d.y!==0?12:8;
          b.x = player.x + (d.x>0?player.w: d.x<0?-range : (player.w/2-4));
          b.y = player.y + (d.y>0?player.h: d.y<0?-range : (player.h/2-4));
        }
      }

      // Boomerang update
      if(boomer){
        if(!boomer.returning){ boomer.x+=boomer.vx; boomer.y+=boomer.vy; boomer.dist+=Math.hypot(boomer.vx,boomer.vy); if(boomer.dist>=boomer.max) boomer.returning=true; }
        if(boomer.returning){ const to={x:player.x+player.w/2, y:player.y+player.h/2}; const dx=to.x-boomer.x, dy=to.y-boomer.y; const d=Math.hypot(dx,dy)||1; boomer.vx=dx/d*2.4; boomer.vy=dy/d*2.4; boomer.x+=boomer.vx; boomer.y+=boomer.vy; if(Math.hypot(to.x-boomer.x,to.y-boomer.y)<4){ boomer=null; } }
      }

      // Enemy updates
      const r=rooms[room];
      for(const e of r.enemies){
        e.dispatch('update', {dt});
      }

      // Combat resolution
      // Melee hits
      if(melee.active){
        for(const e of r.enemies){
          if(!e.alive) continue;
          if(e.dispatch('collide', {box: melee.box})){
            const died = e.dispatch('damage', {amount: 10, source: 'melee'});
            if(died) e.dispatch('death', {room: r});
          }
        }
      }

      // Boomerang damage (pierces, can hit twice - once each way)
      if(boomer){
        for(const e of r.enemies){
          if(!e.alive) continue;
          
          if(e.type === 'bat'){
            const hitKey = boomer.returning ? 1 : 0;
            const wasHit = boomer.hitIds.get(e);
            const alreadyHitThisWay = wasHit && wasHit[hitKey];
            
            if(e.dispatch('pointHit', {x: boomer.x, y: boomer.y}) && !alreadyHitThisWay){
              if(!wasHit) boomer.hitIds.set(e, {0:false, 1:false});
              boomer.hitIds.get(e)[hitKey] = true;
              
              e.dispatch('freeze', {duration: 18});
              const died = e.dispatch('damage', {amount: 5, source: 'boomerang'});
              if(died) e.dispatch('death', {room: r});
            }
          } else if(e.type === 'centi'){
            if(e.dispatch('pointHit', {x: boomer.x, y: boomer.y}) && !boomer.hitIds.has(e)){
              boomer.hitIds.set(e, true);
              e.dispatch('freeze', {duration: 18});
              const died = e.dispatch('damage', {amount: 1, source: 'boomerang'});
              if(died) e.dispatch('death', {room: r});
            }
          }
        }
      }

      // Player vs enemy touch damage with knockback
      if(player.inv>0) player.inv--; else {
        for(const e of r.enemies){
          if(!e.alive) continue;
          if(e.dispatch('collide', {box: player})){
            const center = e.getCenter();
            damagePlayerFrom(center.x, center.y);
            break;
          }
        }
      }

      // Pickups
      for(const it of r.pickups){ if(it.taken) continue; const box={x:it.x,y:it.y,w:it.w,h:it.h}; if(AABB(player,box)){
        if(it.kind==='sword'){ player.hasSword=true; it.taken=true; }
        else if(it.kind==='boom'){ player.hasBoom=true; it.taken=true; }
        else if(it.kind==='heart'){ if(player.hp<30){ player.hp=clamp(player.hp+10,0,30); it.taken=true; } }
      } }

      // doors
      for(const d of r.doors){ const box={x:d.x,y:d.y,w:d.w,h:d.h}; if(AABB(player,box)){
        // begin scroll; player disappears
        beginTransition(d.to, d.dir);
        break;
      } }

      // Rupees update & collection
      updateRupees(r);
    }

    // Death & reset
    if(player.hp<=0){ // reset: send back to room 1, restore hp, respawn enemies; keep pickups acquired
      player.hp=30; room=ROOM.START; player.x=112; player.y=120; player.face='down'; player.inv=0; boomer=null; resetRooms();
      // keep items that were taken
      if(player.hasSword) rooms[ROOM.START].pickups.forEach(p=>{ if(p.kind==='sword') p.taken=true; });
      if(player.hasBoom) rooms[ROOM.GREY].pickups.forEach(p=>{ if(p.kind==='boom') p.taken=true; });
    }

    // === Render ===
    if(!renderTransition(dt)){
      drawRoomBG(rooms[room]);
      drawPickups(rooms[room]);
      drawEnemies(rooms[room]);
      drawRupees(rooms[room]);
      drawBoom();
      drawMelee();
      drawPlayer();
    }
    drawHUD();
    drawRain();

    requestAnimationFrame(loop);
  }

  function rectHitCenti(rect, c){ if(AABB(rect, c.head)) return true; for(const s of c.bodies){ if(AABB(rect,s)) return true; } return false; }
  function pointHitCenti(x,y,c){ const pt={x:x-1,y:y-1,w:2,h:2}; return rectHitCenti(pt,c); }
  function destroyCentiSeg(c){ 
    if(!c.alive) return; 
    if(c.bodies.length>0){ 
      c.bodies.pop(); 
      c.segs--; 
      // Speed up by 15% for each lost segment
      c.speed = c.baseSpeed * (1 + 0.15 * (4 - c.segs));
    } else { 
      // head dies
      c.alive=false; 
      dropRupee(rooms[room], c.head.x+c.w/2, c.head.y+c.h/2); 
      
      // Trigger victory effect in throne room
      if (room === ROOM.THRONE) {
        victoryLight = 1.0;
        rooms[ROOM.THRONE].rain = false;
        rooms[ROOM.THRONE].lightning = false;
      }
    }
  }

  function dropRupee(r, x,y){ 
    // Simple drop - no gravity, just slightly randomize position
    r.rupees.push({
      x:x-4+rng(-2,2), 
      y:y-6+rng(-2,2), 
      w:8, 
      h:12, 
      collected:false
    }); 
  }

  function updateRupees(r){ 
    for(const g of r.rupees){ 
      // No physics - rupees just stay where they dropped
      // pickup check
      if(AABB(player,g)){ 
        inventory.rupees++; 
        g.collected=true; 
      }
    } 
    // Remove collected rupees
    for(let i=r.rupees.length-1;i>=0;i--) {
      if(r.rupees[i].collected) r.rupees.splice(i,1);
    }
  }

  function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

  function damagePlayerFrom(sx,sy){ player.hp-=10; player.inv=60; const dx=player.x+player.w/2 - sx; const dy=player.y+player.h/2 - sy; const d=Math.hypot(dx,dy)||1; const k=2.2; player.x = clamp(player.x + (dx/d)*k*8, 8, LOG_W-8-player.w); player.y= clamp(player.y + (dy/d)*k*8, 16, LOG_H-8-player.h); }

  // Main loop kick - start immediately
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>